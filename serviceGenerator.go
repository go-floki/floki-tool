package main

import (
	"bufio"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"
)

var (
	serviceHeader = `// this file was automatically generated by floki-tool
package services

import (
	"models"
{{.Imports | formatImports}}
)

{{$lowName := .Name | decapitalize}}
{{$mName := printf "%sService" $lowName}}{{if symbolExists .Symbols $mName}}
type {{.Name | decapitalize}}Service struct {
    basicCRUD
}

var {{.Name | capitalize}}Service = {{.Name | decapitalize}}Service{}
{{end}}
`
	serviceMethod = `{{$nameCap := .Name | capitalize}}{{$nameDecap := .Name | decapitalize}}{{$modelCap := .ModelName | capitalize}}{{$modelDecap := .ModelName | decapitalize}}
func (s {{$modelDecap}}Service) FindBy{{$nameCap}} ({{$nameDecap}} {{.FieldType}}) (models.{{$modelCap}}, error){
	entry := models.{{$modelCap}}{}
	err := s.FindByField("{{$nameCap}}", {{$nameDecap}}, &entry)
	return entry, err
}

func (s {{$modelDecap}}Service) FindAllBy{{$nameCap}} ({{$nameDecap}} {{.FieldType}}) ([]models.{{$modelCap}}, error){
	entry := models.{{$modelCap}}{}
	var entries []models.{{$modelCap}}
	err := s.FindAllByField("{{$nameCap}}", {{$nameDecap}}, entry, &entries)
	return entries, err
}
`
)

type ServiceGenerator struct {
	writer    *bufio.Writer
	headerTpl *template.Template
	methodTpl *template.Template
}

type ModuleParams struct {
	Name    string
	Imports []string
	Symbols map[string]string
}

type MethodParams struct {
	ModelName string
	Name      string
	FieldType string
}

func RemoveServiceFiles(dir string, models map[string]*Model) {
	for _, model := range models {
		os.Remove(dir + "/services/" + strings.ToLower(model.Name) + ".go")
	}
}

func GenerateServices(dir string, models map[string]*Model, existingSymbols map[string]string) {
	funcMap := template.FuncMap{
		"capitalize": func(str string) string {
			for i, v := range str {
				return string(unicode.ToUpper(v)) + str[i+1:]
			}
			return ""
		},

		"decapitalize": func(str string) string {
			for i, v := range str {
				return string(unicode.ToLower(v)) + str[i+1:]
			}
			return ""
		},

		"formatImports": func(a []string) string {
			res := ""
			for _, v := range a {
				res += "\t\"" + v + "\"\n"
			}
			return res
		},

		"symbolExists": func(symbols map[string]string, symbol string) bool {
			_, ok := symbols[symbol]
			if ok {
				return false
			}

			return true
		},
	}

	headerTpl, _ := template.New("header").Funcs(funcMap).Parse(serviceHeader)
	methodTpl, _ := template.New("method").Funcs(funcMap).Parse(serviceMethod)

	_ = funcMap
	//headerTpl.Funcs(funcMap)
	//methodTpl.Funcs(funcMap)

	for _, model := range models {
		if _, ok := existingSymbols[strings.ToLower(model.Name)+"Service"]; ok {
			cnt := 0
			for _, field := range model.Fields {
				if _, ok := existingSymbols["FindBy"+field.Names[0]]; !ok {
					cnt++
				}
			}

			if cnt == 0 {
				log.Println("won't generate service for", model.Name, ", because it's already defined.")
				continue
			}
		}

		file, err := os.Create(dir + "/services/" + strings.ToLower(model.Name) + ".go")
		if err != nil {
			log.Fatalln(err)
		}

		defer file.Close()

		g := ServiceGenerator{
			writer:    bufio.NewWriter(file),
			headerTpl: headerTpl,
			methodTpl: methodTpl,
		}

		importMap := make(map[string]bool)
		imports := make([]string, 0)
		for _, field := range model.Fields {
			parts := strings.Split(field.Type, ".")
			if len(parts) == 2 {
				packageName := parts[0]

				if _, ok := importMap[packageName]; !ok {
					imports = append(imports, packageName)
					importMap[packageName] = true
				}
			}
		}

		g.writeHeader(model.Name, imports, existingSymbols)

		for _, field := range model.Fields {
			//log.Println(field.Names[0], field.Type)

			if _, ok := existingSymbols["FindBy"+field.Names[0]]; !ok {
				g.addFinder(model.Name, field)
			}
		}

		g.writer.Flush()
	}

}

func (g ServiceGenerator) addFinder(modelName string, field *Field) {
	g.methodTpl.Execute(g.writer, MethodParams{
		Name:      field.Names[0],
		FieldType: field.Type,
		ModelName: modelName,
	})

}

func (g ServiceGenerator) writeHeader(name string, imports []string, symbols map[string]string) {
	g.headerTpl.Execute(g.writer, ModuleParams{
		Name:    name,
		Imports: imports,
		Symbols: symbols,
	})
}
